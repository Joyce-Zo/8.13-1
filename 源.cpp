#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

                 算 术 操 作 符
 
               除法 与  % 取模 的使用
int main()
{
	int a = 5 / 2;
	        商 2 余 1
	printf("%d\n", a);
	   除法 结果为 2 - 商
	               因为  /  两边均为整型，所以结果也为整数
	int b = 5 % 2;
	printf("%d\n", b);
	   取模 结果为 1 - 余
	double c = 5.0 / 2;
	double d = 5 / 2.0;  //  但凡 / 两边有一个浮点数，结果都是浮点数 
	printf("%lf\n", c);  //  打印用 %lf ,  double 类型结果默认输出6位小数-2.500000
	printf("%lf\n", d);  //  不过 % 符号两边必须都是整型，否则报错（+-*/除外）


	return 0;
}


					移 位 操 作 符
 
int main()
{
	     右移
	int a = 16;
//  int -32 个bit 位，16 = 00000000000000000000000000010000 = 2^4
	int b = a >> 1;
	//  移动的是 二进制位
	//            8 = 00000000000000000000000000001000 = 2^3
	printf("%d\n", b);
	    1.算术右移
	   右边丢弃，左边补原符号位   -   一般都是这个
	    2.逻辑右移
	   右边丢弃，左边补0	
	
	   正数: x>>1 = x/2      x << 1 = x*2
	   负数：x>>1 = (x-1)/2    x << 1 = x*2
	int c = -1;
	整数的二进制表示有：原码、反码、补码，存储到内存的是补码 - 正数三码相同
	  c 原码:10000000000000000000000000000001
	    反码:11111111111111111111111111111110 - 符号位不变，其他0变1
	    补码:11111111111111111111111111111111 - 反码+1
	int d = c >> 1;
	   右移 1 : 符号位不变，右端丢弃
	int f = c << 1;
	printf("%d\n", d);
	printf("%d\n", f);

	      左移
	    左边丢弃，右边补0  = x * 2

	return 0;
}
    注意：不可 移动 负数位 ，如  a >> -1  |   只能作用于整数，not浮点型


				 位 操 作 符
 
   1. 按位与 - &   -  按2进制位与
int main()
{
	int a = 3;
	int b = 5;
	int c = a & b;
	 00000000000000000000000000000011  = 3
	 00000000000000000000000000000101  = 5
	 00000000000000000000000000000001  = 1
	    一个为 0 ，即为 0 ，两个都是 1 ，才是 1 
	printf("%d\n", c);

	return 0;
}

  2. 按位或 - |  - 按2进制位或
int main()
{
	int a = 3;
	int b = 5;
	int c = a | b;
	 00000000000000000000000000000011  = 3
	 00000000000000000000000000000101  = 5
	 00000000000000000000000000000111  = 7
	    只要有 一个 1，两个都成 1
	printf("%d\n", c);

	return 0;
}

  3.  ^ 按位异或 - 2进制位
int main()
{
	int a = 3;
	int b = 5;
	int c = a ^ b;
	 00000000000000000000000000000011  = 3
	 00000000000000000000000000000101  = 5
	 00000000000000000000000000000110  = 6
	    相同 为 0 ，相异 为 1
	printf("%d\n", c);

	return 0;
}
 以上只能 用于 整型 

   设计函数交换两个变量的值
 1.创建临时变量  - 推荐使用
int main()
{
	int a = 3;
	int b = 5;
	int tmp = 0;
	tmp = a;
	a = b;
	b = tmp;
	printf("%d %d", a, b);

	return 0;
}
  2.使用加减法 - int只有4个字节，当数字过大会溢出，丢失数据，不建议使用
int main()
{
	int a = 3;
	int b = 5;
	a = a + b;
	b = a - b;
	a = a - b;

	printf("%d,%d", a, b);

	return 0;
}
   3. 使用 异或  - 执行效率低，可读性差，不推荐
 int main()
{
	int a = 3;// 011	a
	int b = 5;// 101	b
	a = a ^ b;// 110    a
	b = a ^ b;// 011	b
	a = a ^ b;// 101	a

	printf("%d%d", a, b);

	return 0;
}

  计算 某个数存在内存中 的 2进制位有多少个1（补码）
int main()
{
	int num = 0;
	int count = 0;
	scanf("%d", &num);
	  统计num的补码有多少个1
	while (num)
	{
		if (num % 2 == 1)   当 num 为负数，结果错误
		{
			count++;
		}
		num /= 2;
	}
	int i = 0;
	for (i = 0; i < 32; i++)
	{
		if (((num>>i) & 1) == 1)
		{
			count++;
		}
	}
	for (i = 0; i < 32; i++)
	{
		if ((num & 1) == 1)
		{
			num = num >> 1;
			count++;
		}
	}
	printf("%d", count);
	return 0;
}

					赋值操作符
int main()
{
	int a = 5;  //  变量创建时给值 - 初始化
	a = 6;     //   变量创建后修改 - 赋值

	  赋值操作符 可 连续使用
	int b = 5;
	int c = 6;
	int d = 7;
	b = c = d + 1;// 连续赋值 不过不宜读懂，可读性差
	 等价为：
	c = d + 1;
	b = c;

	printf("%d", c);
	return 0;
}

					复合赋值符
int main()
{
	int a, b, c;

	a = a + 1;
	a += 1;

	b = b >> 1;
	b >>= 1;

	c = c % 5;
	c %= 5;
	  以上均等价
	 +=	-=	*=	/=	%=	>>=	<<=	&=	|=	^=
}

				单目操作符  
int main()
{
	int a = 10;
	int* p = &a;	//& 取地址操作符
	*p = 20;  //  解引用操作符
	int a = 5;
	char b = 's';
	char* p = &b;
	int arr[10] = { 0 };
	printf("%d\n", sizeof(a));// int - 4
	printf("%d\n", sizeof a); // 写 元素名 可以省略括号， 写 数据类型 不可省略
	printf("%d\n", sizeof(int));  //  可以写 a-元素名，或者数据类型int	

	printf("%d\n", sizeof(b));// 一个字符 - 1
	printf("%d\n", sizeof(char));

	printf("%d\n", sizeof(p));// 64位 - 8
	printf("%d\n", sizeof(char*));

	printf("%d\n", sizeof(arr));//  10 * 4
	printf("%d\n", sizeof(int [10]));//  去掉arr后的 int [10] 就是数组的类型

	return 0;
}

int main()
{
	short a = 0;
	int b = 10;
	long c = 0;
	printf("%d\n", a);
	printf("%d\n", sizeof(a = b + 5));// 依然是短整型 a 所占空间的大小 - 2
	printf("%d\n", sizeof(c = b + 5));// 依然是长整型 c 所占空间的大小 - 4
	printf("%d\n", sizeof(b));
	return 0;
}

            ~  按 （2进制）位 取 反

int main()
{
	int a = 0;
  00000000000000000000000000 - 原码
  11111111111111111111111111 - 补码
  11111111111111111111111110 - 反码 = 补码 -1  ,此时开始按位取反
  10000000000000000000000001 - 原码 = -1
	printf("%d\n", ~a);
	int a = 11;
  00000000000000000000001011 =11 -> 00000000000000000001111  = 15
与00000000000000000000000100 按位或 即可
即 1<<2 得到 00000000000000000000100
	a = a | (1 << 2);
	printf("%d\n", a);
	int b = 15;
  00000000000000000000001111 = 15 -> 00000000000000000001011 = 11
与11111111111111111111111011 按位与 即可
即00000000000000000000000100 = 5 = 1<<2按位取反 可得上面
	b = b & (~(1 << 2));
	printf("%d\n", b);
	return 0;
}

int main()
{
	int a = 5;
	printf("%d\n", ++a);// 前置++， 先++，后使用 - 直接打印 6
	printf("%d\n", a++);// 后置++， 先打印，后使用 - 直接打印 5，完了++
	printf("%d\n", a);
	return 0;
}

int main()
{
	   类型强制转换
	int a = (int)3.14; // 不可写成 int(3.14)，
	printf("%d\n", a);
	return 0;
}

